# software-engineering-lab-exp2



## جدول تغییرات اعمال‌شده در مرحله اول

| ردیف | محل اعمال تغییرات (کلاس/واسط) | عنوان تغییر                           | شرحی کوتاه از تغییر                                                                           |
| ---- | ----------------------------- | ------------------------------------- | --------------------------------------------------------------------------------------------- |
| ۱    | `models package`              | افزودن `TelegramMessage class`        | ایجاد یک کلاس جدید که از `Message` ارث‌بری می‌کند و دارای فیلدهای `sourceId` و `targetId` است |
| ۲    | `TelegramMessage`             | افزودن `getSourceId method`           | متد getter برای شناسه تلگرام فرستنده                                                          |
| ۳    | `TelegramMessage`             | افزودن `setSourceId method`           | متد setter برای شناسه تلگرام فرستنده                                                          |
| ۴    | `TelegramMessage`             | افزودن `getTargetId method`           | متد getter برای شناسه تلگرام گیرنده                                                           |
| ۵    | `TelegramMessage`             | افزودن `setTargetId method`           | متد setter برای شناسه تلگرام گیرنده                                                           |
| ۶    | `services package`            | افزودن `TelegramMessageService class` | ایجاد یک کلاس جدید که `MessageService interface` را پیاده‌سازی می‌کند                         |
| ۷    | `TelegramMessageService`      | افزودن `sendTelegramMessage method`   | متدی جهت صحت‌سنجی و ارسال پیام تلگرام                                                         |
| ۸    | `TelegramMessageService`      | افزودن `validateTelegramId method`    | یک متد خصوصی برای صحت‌سنجی فرمت‌های شناسه تلگرام (نام کاربری، آی‌دی عددی، شماره تماس)         |
| ۹    | `TelegramMessageService`      | پیاده‌سازی `sendSmsMessage method`    | پیاده‌سازی خالی (به علت الزامی بودن در `MessageService`)                                      |
| ۱۰   | `TelegramMessageService`      | پیاده‌سازی `sendEmailMessage method`  | پیاده‌سازی خالی (به علت الزامی بودن در `MessageService`)                                      |

---

## تغییر مورد نیاز اضافه (هنوز پیاده‌سازی نشده)

| ردیف | محل اعمال تغییرات (کلاس/واسط) | عنوان تغییر                         | شرحی کوتاه از تغییر                                  |
| ---- | ----------------------------- | ----------------------------------- | ---------------------------------------------------- |
| ۱۱   | `MessageService`              | افزودن `sendTelegramMessage method` | افزودن امضای متد void برای ارسال پیام تلگرام در واسط |

---

### تعداد کل تغییرات مورد نیاز: **۱۱**

**توضیح**: پیاده‌سازی فعلی دارای یک نقص طراحی است. متد `sendTelegramMessage` فقط در کلاس `TelegramMessageService` وجود دارد و در `MessageService interface` تعریف نشده است. در نتیجه، سایر کلاس‌های سرویس اجباری به پیاده‌سازی این متد ندارند که این موضوع نقض قرارداد واسط است. ردیف ۱۱ تغییر اضافی مورد نیاز را نشان می‌دهد که با افزودن امضای این متد به `MessageService`، باید کلاس‌های `SmsMessageService` و `EmailMessageService` نیز این متد را (احتمالاً با بدنه خالی) پیاده‌سازی کنند.


در این بخش، به تحلیل رعایت یا نقض اصول پنج‌گانه SOLID در کلاس‌های بسته‌ی `services` و کلاس `Main` پرداخته شده است. نتایج در جدول زیر ارائه شده‌اند:

---

## جدول مرحله دوم: موارد تحقق و نقض اصول SOLID

| شماره اصل | نام اصل                         | موارد تحقق                                                                                                                                                                                                  | موارد نقض                                                                                                                                                                                        |
| --------- | ------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| اصل 1     | Single Responsibility Principle | —                                                                                                                                                                                                           | —                                                                                                                                                                                                |
| اصل 2     | Open-Closed Principle (OCP)     | کلاس‌های مشتق‌شده از Message (مثل TelegramMessage) قابلیت توسعه بدون نیاز به تغییر در کلاس والد را فراهم می‌کنند                                                                                            | واسط MessageService برای اضافه‌کردن نوع پیام جدید باید تغییر کند؛ سرویس‌های قبلی نیز باید برای پیاده‌سازی متد جدید تغییر یابند                                                                   |
| اصل 3     | Liskov Substitution Principle   | همه‌ی کلاس‌های سرویس (مانند SmsMessageService، EmailMessageService، TelegramMessageService) قابلیت جایگزینی به‌جای واسط MessageService را دارند؛ همچنین TelegramMessage نیز جایگزین مناسبی برای Message است | —                                                                                                                                                                                                |
| اصل 4     | Interface Segregation Principle | —                                                                                                                                                                                                           | واسط MessageService همه‌ی پیاده‌سازی‌ها را مجبور به تعریف متدهایی می‌کند که عملاً استفاده نمی‌شوند (برای مثال، SmsMessageService باید متد بی‌کاربرد sendEmailMessage را پیاده‌سازی کند و بالعکس) |
| اصل 5     | Dependency Inversion Principle  | کلاس Main از متغیر نوع MessageService برای رفتار چندریختی استفاده می‌کند                                                                                                                                    | در کلاس Main، نمونه‌سازی به‌صورت مستقیم از کلاس‌های مشخص (مثل `new SmsMessageService()` و `new EmailMessageService()`) صورت گرفته که برخلاف اصل وابستگی به انتزاع است                            |

---

### مشاهدات:

* **بیشترین نقض مربوط به اصل**: **Interface Segregation Principle (ISP)**
  هر کلاس سرویس مجبور به پیاده‌سازی متدهایی برای نوع پیام‌هایی است که با آن‌ها کار نمی‌کند؛ در نتیجه پیاده‌سازی‌های خالی و بی‌استفاده در سراسر کد وجود دارد.

* **نقض بحرانی**: **Open-Closed Principle (OCP)**
  برای اضافه کردن یک نوع پیام جدید (مثل پیام تلگرام)، باید واسط اصلی تغییر کند و در ادامه همه‌ی کلاس‌های قبلی نیز باید برای انطباق با این تغییر به‌روزرسانی شوند. این موضوع برخلاف اصل بسته بودن در برابر تغییر است.

* **بهترین رعایت**: **Liskov Substitution Principle (LSP)**
  ساختار ارث‌بری و پیاده‌سازی کلاس‌ها به‌گونه‌ای است که هر پیاده‌سازی به‌درستی قابل جایگزینی با کلاس والد یا واسط خود می‌باشد و رفتار صحیحی ارائه می‌دهد.

---

## جدول مرحله سوم: نقض اصول SOLID و راهکارهای پیشنهادی

| اصل نقض‌شده (از اصول SOLID)               | علت نقض                                                                                                                                                                     | راه حل پیشنهادی                                                                                                                                                                                                                                                                                                                                                |
| ----------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Open-Closed Principle (OCP)**           | افزودن نوع جدیدی از پیام (مانند TelegramMessage) مستلزم تغییر در واسط MessageService و همچنین به‌روزرسانی پیاده‌سازی‌های موجود است.                                         | **راه‌حل ۱**: ایجاد واسط‌های جداگانه برای هر نوع پیام، مانند ISmsMessageService، IEmailMessageService و ITelegramMessageService که از یک واسط پایه به‌نام IMessageService ارث‌بری کنند.<br><br>**راه‌حل ۲**: استفاده از واسط کلی‌سازی‌شده‌ی MessageService\<T> که در آن T نوع پیام است. این ساختار اجازه می‌دهد بدون تغییر کدهای قبلی، قابلیت گسترش فراهم شود. |
| **Interface Segregation Principle (ISP)** | واسط MessageService همه‌ی پیاده‌سازی‌ها را مجبور به داشتن متدهایی می‌کند که به آن‌ها مربوط نیست (مثلاً SmsMessageService مجبور به پیاده‌سازی متد خالی sendEmailMessage است) | **راه‌حل**: شکستن MessageService به واسط‌های کوچک‌تر و هدفمندتر:<br>– ISmsMessageService با متد sendSmsMessage(SmsMessage)<br>– IEmailMessageService با متد sendEmailMessage(EmailMessage)<br>– ITelegramMessageService با متد sendTelegramMessage(TelegramMessage)<br><br>سپس، هر کلاس سرویس فقط واسط مربوط به نوع پیام خودش را پیاده‌سازی کند.               |
| **Dependency Inversion Principle (DIP)**  | کلاس Main به‌طور مستقیم کلاس‌های سرویس پیاده‌سازی‌شده را ایجاد می‌کند (مانند new SmsMessageService()) که منجر به وابستگی سخت به پیاده‌سازی‌ها می‌شود.                       | **راه‌حل ۱**: استفاده از الگوی ServiceFactory یا ServiceProvider برای ایجاد نمونه‌ی سرویس‌ها بر اساس نوع پیام.<br><br>**راه‌حل ۲**: استفاده از تزریق وابستگی (Dependency Injection) به‌طوری‌که سرویس‌ها از طریق سازنده به کلاس Main تزریق شوند.<br><br>**راه‌حل ۳**: استفاده از MessageServiceRegistry برای نگاشت نوع پیام به سرویس مربوطه.                    |

---
# پاسخ سوالات
##  سوال اول

### **تغییراتی که با رعایت اصول SOLID غیرضروری می‌شدند:**

| ردیف | تغییر                                                                           | دلیل عدم نیاز در صورت رعایت SOLID                                                                          |
| ---- | ------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| ۹    | پیاده‌سازی متد `sendSmsMessage` در کلاس `TelegramMessageService` (بدون محتوا)   | **نقض اصل ISP**: در صورت جداسازی صحیح واسط‌ها، این کلاس فقط واسط مخصوص به پیام تلگرام را پیاده‌سازی می‌کرد |
| ۱۰   | پیاده‌سازی متد `sendEmailMessage` در کلاس `TelegramMessageService` (بدون محتوا) | **نقض اصل ISP**: در طراحی درست نیازی به پیاده‌سازی متدهای نامربوط نیست                                     |
| ۱۱   | افزودن متد `sendTelegramMessage` به واسط `MessageService`                       | **نقض اصل OCP**: در صورت طراحی مناسب، نیازی به تغییر واسط عمومی برای افزودن قابلیت جدید نبود               |

**تعداد تغییرات غیرضروری: ۳ مورد**

---

### **تغییراتی که همچنان لازم هستند:**

| ردیف   | تغییر                                                | دلیل نیاز به تغییر                            |
| ------ | ---------------------------------------------------- | --------------------------------------------- |
| ۱ تا ۵ | ایجاد کلاس `TelegramMessage` و متدهای آن             | افزودن قابلیت جدید نیازمند ایجاد مدل جدید است |
| ۶ تا ۸ | ایجاد کلاس `TelegramMessageService` و متدهای اصلی آن | پیاده‌سازی منطق تجاری جدید لازم است           |

**تعداد تغییرات باقی‌مانده: ۸ مورد**

---

### **تغییرات غیرضروری:** **۳ مورد از ۱۱**

### **تعداد تغییرات مورد نیاز با رعایت کامل SOLID:** **۵ تغییر**

اگر اصول SOLID از ابتدا رعایت می‌شدند، افزودن سرویس تلگرام تنها به تغییرات زیر نیاز داشت:

1. **ایجاد کلاس `TelegramMessage`** (۱ تغییر)
2. **ایجاد واسط `ITelegramMessageService`** (۱ تغییر)
3. **ایجاد پیاده‌سازی `TelegramMessageService`** (۱ تغییر)
4. **افزودن آن به کارخانه‌ی سرویس‌ها (ServiceFactory)** (۱ تغییر)
5. **بروزرسانی منو و منطق کلاس Main** (۱ تغییر)

---

##  **بررسی بیشتر اعداد:**

* **در حالت بدون SOLID:** نیاز به ۱۱ تغییر
* **در حالت رعایت کامل SOLID:** تنها ۵ تغییر
* **کاهش تغییرات:** کاهش ۵۴٪ در حجم تغییرات
* **مزایای طراحی صحیح:** حذف متدهای بدون استفاده، حذف نیاز به تغییر واسط‌ها، عدم نیاز به بازسازی کد برای رعایت اصول طراحی

**ارقام نهایی:**

* **تغییرات غیرضروری:** ۳ مورد
* **تعداد تغییرات لازم در طراحی اصولی:** ۵ مورد





---

## سوال دوم

### ۱. **قابلیت توسعه از طریق رعایت اصل Open-Closed**

**پیش از رعایت اصول SOLID**: برای افزودن پیام تلگرام (TelegramMessage)، لازم بود تا واسط `MessageService` تغییر کند. این تغییر باعث شد کلاس‌های `SmsMessageService` و `EmailMessageService` نیز تغییر یابند، در حالی که ارتباطی با پیام‌های تلگرام نداشتند.

**پس از رعایت SOLID**: با ایجاد واسط‌های جداگانه‌ای مانند `ISmsMessageService`، `IEmailMessageService` و `ITelegramMessageService`، سیستم به‌گونه‌ای طراحی شد که «برای توسعه باز و برای تغییر بسته» باشد. در این حالت، افزودن نوع جدیدی از پیام نیازی به تغییر در کدهای موجود ندارد.

---

### ۲. **تفکیک صحیح وظایف با رعایت اصل Interface Segregation**

**پیش از SOLID**: هر کلاس سرویس مجبور بود متدهایی را پیاده‌سازی کند که استفاده‌ای از آن‌ها نمی‌کرد. به‌عنوان نمونه:

```java
public class SmsMessageService implements MessageService {
    public void sendSmsMessage(SmsMessage msg) { /* پیاده‌سازی واقعی */ }
    public void sendEmailMessage(EmailMessage msg) { /* خالی */ }
    public void sendTelegramMessage(TelegramMessage msg) { /* خالی */ }
}
```

**پس از SOLID**: هر سرویس تنها واسط مربوط به خود را پیاده‌سازی می‌کند:

```java
public class SmsMessageService implements ISmsMessageService {
    public void sendSmsMessage(SmsMessage msg) { /* پیاده‌سازی واقعی */ }
    // نیازی به متدهای خالی دیگر نیست
}
```

---

### ۳. **وابستگی‌های انعطاف‌پذیر با رعایت اصل Dependency Inversion**

**پیش از SOLID**: کلاس `Main` به‌طور مستقیم وابسته به پیاده‌سازی‌های مشخص بود:

```java
messageService = new SmsMessageService(); // وابستگی سخت به پیاده‌سازی
```

**پس از SOLID**: کلاس `Main` از طریق الگوی کارخانه، وابستگی خود را به واسط‌ها تعریف می‌کند:

```java
ISmsMessageService smsService = MessageServiceFactory.createSmsService();
```

---

## کاهش پیچیدگی و بهبود در نگه‌داری

### کاهش پیچیدگی کد:

* حذف ۶ متد خالی در کلاس‌های مختلف
* کاهش تعداد تغییرات لازم برای افزودن قابلیت جدید از ۱۱ به ۵ (معادل ۵۴٪ کاهش)
* حذف اجبار به پیاده‌سازی متدهای نامرتبط در واسط‌ها

### بهبود نگه‌داری سیستم:

* هر کلاس تنها یک وظیفه مشخص دارد
* امکان تست آسان هر کلاس به‌صورت مجزا
* کاهش احتمال بروز خطاهای ناشی از صدا زدن متدهای خالی

---

## تاثیر در دنیای واقعی

### برای توسعه‌دهندگان:

* سرعت بیشتر در توسعه ویژگی‌های جدید مانند پیام‌های WhatsApp یا Signal
* اطمینان بیشتر در بازسازی (Refactor) کد بدون ایجاد اختلال
* وضوح بالاتر در وظیفه و کارکرد هر کلاس و واسط

### برای رشد سیستم:

* امکان استفاده از فناوری‌های مختلف برای پیاده‌سازی سرویس‌ها (مانند REST API یا صف‌های پیام‌رسان)
* امکان توسعه همزمان توسط تیم‌های مختلف بر روی انواع پیام‌ها
* قابلیت مدیریت نسخه‌های مختلف سرویس‌ها در زمان مهاجرت یا تغییرات بزرگ

---

## نمونه عملی از مزایای طراحی صحیح

**سناریو**: افزودن قابلیت ارسال پیام WhatsApp

**در طراحی قدیمی (بدون SOLID)**:

1. نیاز به تغییر در `MessageService` 
2. نیاز به افزودن متدهای خالی در سرویس‌های موجود 
3. احتمال بروز اختلال در عملکرد فعلی 
4. حداقل ۸ تغییر در کد 

**در طراحی جدید (با SOLID)**:

1. ایجاد واسط `IWhatsAppMessageService` 
2. ایجاد کلاس `WhatsAppMessageService` 
3. افزودن به کارخانه سرویس‌ها 
4. بروزرسانی منوی کلاس Main 
5. تنها ۴ تغییر در کد 
6. بدون تاثیر بر سرویس‌های موجود 

---

رعایت اصول شی‌گرایی باعث شد سیستم پیام‌رسانی از ساختاری سخت و وابسته، به معماری‌ای منعطف، قابل نگه‌داری و قابل توسعه تبدیل شود. این ساختار جدید هزینه و ریسک توسعه‌های آینده را کاهش می‌دهد.
